<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="style.css">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>오답노트</title>
</head>
<body>
  <nav class="app-nav" aria-label="네비게이션">
    <div class="nav-links">
      <button class="shift-btn" onclick="location.href='index.html'">단어장</button>
      <button class="shift-btn" onclick="location.href='calendar.html'">캘린더</button>
    </div>
    <div class="nav-tools">
      <button id="studyTimerActionBtn" class="mobile-hide-on-phone" onclick="handleStudyTimerActionButtonClick()">순공 타이머 시작</button>
      <button id="studyTimerDisplay" class="timer-chip mobile-hide-on-phone" onclick="handleTimerDisplayClick()">순공 00:00:00</button>
      <button type="button" id="mobileTimerQuickBtn" class="mobile-timer-btn shift-btn" onclick="openTimerQuickMenu()">⏰타이머</button>
    </div>
  </nav>

  <div class="container">
    <div class="word-import-modal custom-words-modal result-note-modal" role="region" aria-label="오답노트">
      <h2>오답노트</h2>
      <div class="word-import-actions result-note-actions">
        <button type="button" onclick="copyWrongWords()">복사하기</button>
      </div>
      <p id="wrongSummary">0개</p>
      <div id="wrongList" class="custom-words-list" aria-live="polite"></div>
    </div>
  </div>

  <script>
    const CUSTOM_WORDS_KEY = "customWords";
    const CUSTOM_WORDS_SESSION_KEY = "customWordsSessionBackup";
    let wrongNoteItems = [];

    function parseJsonArray(raw) {
      try {
        const parsed = JSON.parse(raw || "[]");
        return Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        return [];
      }
    }

    function buildWordMap(wordList) {
      const map = new Map();
      (wordList || []).forEach(item => {
        if (!item || !item.word) return;
        const word = String(item.word).trim();
        const meanings = Array.isArray(item.meanings)
          ? item.meanings.map(v => String(v).trim()).filter(Boolean)
          : [];
        if (!word) return;
        map.set(word, { word, meanings });
      });
      return map;
    }

    async function loadBaseWords() {
      try {
        const response = await fetch("words.json");
        const text = await response.text();
        if (!text.trim()) return [];
        return parseJsonArray(text);
      } catch (error) {
        return [];
      }
    }

    function renderWrongWords(items) {
      const summaryEl = document.getElementById("wrongSummary");
      const listEl = document.getElementById("wrongList");
      if (!summaryEl || !listEl) return;

      summaryEl.innerText = `${items.length}개`;
      listEl.innerHTML = "";

      if (items.length === 0) {
        const empty = document.createElement("p");
        empty.className = "custom-words-empty";
        empty.innerText = "오답 기록이 없습니두.😎";
        listEl.appendChild(empty);
        return;
      }

      items.forEach(item => {
        const row = document.createElement("div");
        row.className = "custom-word-item";

        const wordEl = document.createElement("div");
        wordEl.className = "custom-word-title";
        wordEl.innerText = item.word;

        const meaningsEl = document.createElement("div");
        meaningsEl.className = "custom-word-meanings";
        meaningsEl.innerText = item.meanings.length > 0
          ? item.meanings.join(", ")
          : "뜻 정보 없음";

        row.appendChild(wordEl);
        row.appendChild(meaningsEl);
        listEl.appendChild(row);
      });
    }

    function buildWordExportText(items) {
      return (items || [])
        .map(item => {
          const word = String(item?.word || "").trim();
          const meanings = Array.isArray(item?.meanings)
            ? item.meanings.map(v => String(v).trim()).filter(Boolean)
            : [];
          if (!word) return "";
          return `${word}\n${(meanings.length ? meanings : ["뜻 정보 없음"]).join(", ")}`;
        })
        .filter(Boolean)
        .join("\n");
    }

    async function copyText(text, successMessage) {
      if (!text || !String(text).trim()) {
        alert("복사할 내용이 없어요.");
        return;
      }

      try {
        await navigator.clipboard.writeText(text);
        alert(successMessage);
      } catch (error) {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        textarea.style.position = "fixed";
        textarea.style.opacity = "0";
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        const copied = document.execCommand("copy");
        document.body.removeChild(textarea);
        if (copied) {
          alert(successMessage);
        } else {
          alert("복사 권한이 막혀 있습니두😿 직접 복사해주세잉.ㅎ");
        }
      }
    }

    async function copyWrongWords() {
      await copyText(buildWordExportText(wrongNoteItems), "오답노트 복사 완료!");
    }

    window.copyWrongWords = copyWrongWords;

    (async () => {
      const wrongWords = parseJsonArray(localStorage.getItem("wrongWords"));
      const baseWords = await loadBaseWords();
      const localCustomWords = parseJsonArray(localStorage.getItem(CUSTOM_WORDS_KEY));
      const sessionCustomWords = parseJsonArray(sessionStorage.getItem(CUSTOM_WORDS_SESSION_KEY));

      const combinedMap = buildWordMap(baseWords);
      buildWordMap(sessionCustomWords).forEach((value, key) => combinedMap.set(key, value));
      buildWordMap(localCustomWords).forEach((value, key) => combinedMap.set(key, value));

      wrongNoteItems = wrongWords.map(word => {
        const normalizedWord = String(word).trim();
        const found = combinedMap.get(normalizedWord);
        return found || { word: normalizedWord, meanings: [] };
      });

      renderWrongWords(wrongNoteItems);
    })();
  </script>
  <script src="help-modal.js"></script>
  <script src="patch-notice.js"></script>
  <script src="todo-widget.js"></script>
  <script src="timer-nav.js"></script>
</body>
</html>
